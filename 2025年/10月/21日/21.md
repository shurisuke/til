① レイアウトでの script 読み込み準備
- admin.html.slim で = javascript_include_tag 'admin' により、app/assets/javascripts/admin.js が読み込まれる。
- yield 'scripts' も定義されており、各ページが必要に応じて追加の JS を挿入できるようにしてある。

⸻

② edit.html.slim で edit_article.js を明示的に読み込んでいる
- ここで <%= content_for :scripts do %> 内に javascript_pack_tag 'edit_article'（または javascript_include_tag）などで edit_article.js を読み込んでいる。

⸻

③ edit_article.js から articleBlockEditor/index.js を import
- ここで React による描画処理を含む独自のエディタロジックを読み込む。
- jQuery のプラグイン拡張（例: .articleBlockEditor()）もこの中で定義される。

⸻

④ index.js 内の処理
- $(el).articleBlockEditor() が呼ばれると、React で <Editor /> コンポーネント（= RichTextEditor）を textarea にマウントする。
- onChange も定義されていて、HTML 文字列が反映されるようになっている。

⸻

⑤ .js-article-block-forms に対して DOM 操作 & Ajax リスナーを設定
- admin.js の中で .js-article-block-forms を対象に、ajax:success など多数のイベントリスナーが登録される。
- また初回ロード時に reload() が実行され、Ajax によって GET /admin/articles/:uuid/article_blocks が走る。

⸻

⑥ Admin::Articles::ArticleBlocksController#index が呼ばれる
- @article_blocks = ArticleBlock.where(article_id: ...) のように取得。
- render 'index' により、index.html.slim を返す（HTML フラグメント）。

⸻

⑦ views/admin/articles/article_blocks/index.html.slim
- 上部に insert_block を1つ描画。
- その後、@article_blocks.each で各ブロックを article_block として描画し、その下に insert_block も再度挿入。
→ 見た目としてはブロックとブロックの間に「追加できる UI」が差し込まれるような構造。

⸻

⑧ insert_block の中で「ブロックを構築する」ボタンがあり、これが Ajax リクエストを発火
- 例えば POST /admin/articles/:uuid/article_blocks で create アクションへ。
- 成功すれば再度 reload() → index アクションで UI を更新。

⸻

⑨ article_block のパーシャルでは個々の UI を構築
- ブロックを上下に動かすボタン（↑↓）→ Ajax による PATCH リクエスト（swap）
- ゴミ箱アイコン → DELETE リクエスト
- .js-article-block-content の中では sentence?, medium?, embed? に応じてそれぞれ異なるパーシャルを描画。
- これはブロックのタイプごとに中身が違うという設計。
